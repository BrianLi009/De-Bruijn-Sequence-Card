#!/usr/bin/python

import string
import random

test_deck = 3*list(range(1,14))

shuffled_deck = random.sample(test_deck, len(test_deck))

window_length=5

def Tie(deck):
    Tie=False
    for i in range(1,window_length):
        for j in range(0, len(deck) - i):
            if deck[j]==deck[i+j]:
                Tie=True
    return Tie

def TieIndex(deck):
    """Returns the index of the second occurence of a tie in a deck.
    If there is no tie, then it returns 0."""
    Tie=0
    for i in range(1,window_length):
        for j in range(0, len(deck) - i):
            if deck[j]==deck[i+j]:
                Tie=i+j
    return Tie


def GenerateNoTie(deck):
        new_deck = list(deck)
        #print new_deck;
        while Tie(new_deck):
            ## DO SOMETHING TO FIX TIE!
            index_of_tie=TieIndex(deck)
            new_deck=random.sample(new_deck,len(new_deck))
        return(new_deck)

def Order(cards):
    """Given a packet of cards, Order tells us about their rank order.
    It returns the indices of the cards listed by increasing rank.
    Thus, cards[Order[0]] is the lowest card, and cards[Order[N]] is the highest."""
    order=list(cards)
    order.sort()
    return map(lambda x : cards.index(x), order)

def TopThree(cards):
    order=list(Order(cards))
    return order[-3:]

def LMHCoding(deck):
    for i in range(0,len(deck) - window_length + 1):
        cards = list(deck[i:i+window_length])
        print(str(cards) + " --> " + str(TopThree(cards)))

def deBruijn(deck):
    deBruijn=True
    lookup_table = dict()
    for i in range(0,len(deck) - window_length + 1):
        cards = list(deck[i:i+window_length])
        if not str(TopThree(cards)) in lookup_table:
            # print TopThree(cards);
            #print str(cards) + "-->" + str(TopThree(cards));
            lookup_table[str(TopThree(cards))] = i
        else:
            #print str(cards) + "-->" + str(TopThree(cards));
            deBruijn=False
            return deBruijn
    return deBruijn

def generate_partial():
    """generate_partial function will generate a De Bruijn Sequence with length 39 (3 suits)"""
    for i in range(10**7):
        shuffled_deck = random.sample(test_deck, len(test_deck))
        if (not Tie(shuffled_deck) and (deBruijn(shuffled_deck))):
            print(shuffled_deck)
            print("This deck has a tie: " + str(Tie(shuffled_deck)))
            print("This deck is deBruijn: " + str(deBruijn(shuffled_deck)) + "\n")

# we eventually obtained this sequence

partial_deck = [8,10,4,2,7,1,11,10,3,5,12,8,6,3,7,9,4,6,11,10,13,1,5,2,7,13,12,5,1,4,3,2,9,11,13,8,6,12,9]
left_over = [1,2,3,4,5,6,7,8,9,10,11,12,13]
# these are the leftover cards that is not in the partial De Bruijn sequence just yet


def insert_card(partial_deck, left_over):
    """input: takes in the output from function generate_partial()
       output: a full De Bruijn sequence with length of 52, 4 suits"""
    for num in left_over:
        copy_deck = partial_deck[:]
        for i in range(len(partial_deck)):
            copy_deck.insert(i, num)
            if (not Tie(copy_deck) and (deBruijn(copy_deck))):
                left_over.remove(num)
                insert_card(copy_deck, left_over)
            else:
                del copy_deck[i]
        print (copy_deck)
        print (len(copy_deck))

shuffled_leftover = random.sample(left_over, len(left_over))
insert_card(partial_deck, shuffled_leftover)

#This function is a bit buggy, sometimes it might yield list.remove(x): x not in list.
#However, it is still yielding De Bruijn sequence with length 52, which is what we want
#So far, I have generated these proper sequence:
gooddeck1 = [13, 8, 12, 10, 11, 2, 5, 9, 1, 8, 10, 4, 3, 2, 7, 1, 11, 6, 4, 10, 3, 7, 5, 12, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 13, 12, 5, 1, 4, 3, 2, 9, 11, 13, 8, 6, 12, 9]
gooddeck2 = [11, 13, 2, 1, 8, 10, 4, 3, 2, 7, 1, 11, 10, 3, 5, 12, 9, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 12, 4, 5, 2, 7, 13, 12, 5, 6, 1, 4, 3, 2, 9, 11, 13, 8, 6, 12, 5, 7, 10, 8, 9]
gooddeck3 = [4, 12, 2, 6, 13, 3, 11, 8, 9, 10, 5, 4, 2, 7, 1, 11, 10, 3, 5, 12, 8, 10, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 8, 13, 12, 5, 1, 4, 3, 2, 9, 11, 7, 13, 8, 6, 12, 1, 9]
gooddeck4 = [1, 4, 13, 2, 10, 5, 7, 11, 6, 12, 3, 8, 10, 4, 2, 7, 1, 11, 10, 3, 5, 12, 9, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 13, 8, 12, 5, 1, 4, 3, 2, 9, 11, 13, 8, 6, 12, 9]
gooddeck5 = [6, 7, 13, 9, 4, 5, 12, 2, 11, 1, 3, 8, 10, 4, 2, 7, 1, 11, 10, 3, 5, 12, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 13, 10, 12, 8, 5, 1, 4, 3, 2, 9, 11, 13, 8, 6, 12, 9]
gooddeck6 = [10, 8, 2, 1, 13, 5, 6, 9, 12, 8, 10, 4, 3, 2, 7, 1, 11, 4, 10, 3, 7, 5, 12, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 13, 12, 5, 1, 4, 3, 2, 9, 11, 13, 8, 6, 12, 11, 9]
gooddeck7 = [1, 12, 2, 10, 4, 8, 11, 5, 9, 6, 13, 8, 10, 4, 3, 2, 7, 1, 11, 10, 3, 5, 12, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 13, 12, 5, 1, 4, 3, 2, 9, 11, 7, 13, 8, 6, 12, 9]
gooddeck8 = [13, 5, 2, 8, 12, 7, 4, 6, 10, 1, 9, 3, 11, 8, 10, 4, 2, 7, 1, 11, 10, 3, 5, 12, 8, 6, 3, 7, 9, 4, 6, 11, 10, 13, 1, 5, 2, 7, 13, 12, 5, 1, 4, 3, 2, 9, 11, 13, 8, 6, 12, 9]
